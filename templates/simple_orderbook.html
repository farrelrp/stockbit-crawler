{% extends "base.html" %} {% block title %}Simple Orderbook View{% endblock %}
{% block content %}
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css" />
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>

<style>
  .orderbook-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
  }

  .orderbook-side {
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .orderbook-side.bid {
    border-left: 4px solid #28a745;
  }

  .orderbook-side.offer {
    border-left: 4px solid #dc3545;
  }

  .orderbook-table {
    width: 100%;
    font-family: "Courier New", monospace;
    font-size: 14px;
  }

  .orderbook-table th {
    background: #f8f9fa;
    padding: 10px;
    text-align: right;
    font-weight: 600;
    border-bottom: 2px solid #dee2e6;
  }

  .orderbook-table td {
    padding: 8px 10px;
    text-align: right;
    border-bottom: 1px solid #f0f0f0;
  }

  .orderbook-table tr:hover {
    background: #f8f9fa;
  }

  .change-positive {
    color: #28a745;
    font-weight: bold;
  }

  .change-negative {
    color: #dc3545;
    font-weight: bold;
  }

  .live-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    background: #28a745;
    border-radius: 50%;
    animation: pulse 1s infinite;
  }

  @keyframes pulse {

    0%,
    100% {
      opacity: 1;
    }

    50% {
      opacity: 0.3;
    }
  }

  .status-bar {
    background: white;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .btn {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    margin: 0 5px;
  }

  .btn-success {
    background: #28a745;
    color: white;
  }

  .btn-danger {
    background: #dc3545;
    color: white;
  }

  .btn-warning {
    background: #ffc107;
    color: #000;
  }

  .btn-primary {
    background: #007bff;
    color: white;
  }

  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
</style>

<div class="container">
  <h1 class="mb-4">
    <i class="bi bi-bar-chart-line"></i> Simple Orderbook View
    <span class="live-indicator"></span>
  </h1>

  <div class="alert alert-info">
    <strong>üìä Real-time Orderbook Ladder</strong> - This view updates every
    100ms with live market data
  </div>

  <div class="status-bar">
    <div>
      <strong>Status:</strong> <span id="status">Loading...</span> |
      <strong>Time:</strong> <span id="currentTime">--:--:--</span> |
      <strong>Updates:</strong> <span id="updateCount">0</span> |
      <strong>Speed:</strong> <span id="speed">1.0x</span> |
      <strong>Progress:</strong> <span id="progress">0/0</span> |
      <strong>Levels:</strong> <span id="levels">0</span>
    </div>
    <div>
      <select id="fileSelect" class="form-control" style="display: inline-block; width: auto; margin-right: 10px">
        <option value="">Loading files...</option>
      </select>
      <button class="btn btn-primary" onclick="loadFile()">Load</button>
      <button class="btn btn-success" id="startBtn" onclick="startReplay()">
        ‚ñ∂ Start
      </button>
      <button class="btn btn-warning" id="pauseBtn" onclick="pauseReplay()" disabled>
        ‚è∏ Pause
      </button>
      <button class="btn btn-success" id="resumeBtn" onclick="resumeReplay()" disabled style="display: none">
        ‚ñ∂ Resume
      </button>
      <button class="btn btn-danger" id="stopBtn" onclick="stopReplay()" disabled>
        ‚èπ Stop
      </button>
      <div class="speed-buttons" style="display: inline-flex; gap: 5px; margin-left: 10px;">
        <button class="btn btn-sm btn-secondary speed-btn" data-speed="1" onclick="setSpeed(1)">1s</button>
        <button class="btn btn-sm btn-secondary speed-btn" data-speed="5" onclick="setSpeed(5)">5s</button>
        <button class="btn btn-sm btn-secondary speed-btn active" data-speed="10" onclick="setSpeed(10)">10s</button>
        <button class="btn btn-sm btn-secondary speed-btn" data-speed="30" onclick="setSpeed(30)">30s</button>
        <button class="btn btn-sm btn-secondary speed-btn" data-speed="60" onclick="setSpeed(60)">1m</button>
        <button class="btn btn-sm btn-secondary speed-btn" data-speed="180" onclick="setSpeed(180)">3m</button>
        <button class="btn btn-sm btn-secondary speed-btn" data-speed="300" onclick="setSpeed(300)">5m</button>
      </div>
    </div>
  </div>

  <div style="margin: 20px 0; padding: 15px; background: white; border-radius: 8px">
    <div style="display: flex; align-items: center; gap: 10px">
      <strong>Timeline:</strong>
      <input type="range" id="timeScrubber" min="0" max="100" value="0" disabled
        style="flex: 1; height: 8px; cursor: pointer" oninput="onScrubberInput()" onchange="onScrubberChange()" />
      <span id="scrubberPosition" style="min-width: 80px; font-family: monospace">0 / 0</span>
      <div
        style="display: flex; align-items: center; gap: 5px; margin-left: 15px; border-left: 1px solid #ccc; padding-left: 15px;">
        <label style="font-size: 0.9em;">Go to:</label>
        <input type="time" id="gotoTimeInput" step="1"
          style="padding: 4px 8px; border: 1px solid #ccc; border-radius: 4px;" />
        <button class="btn btn-sm btn-primary" onclick="gotoTime()" style="padding: 4px 12px;">Go</button>
      </div>
    </div>
  </div>

  <!-- 10s Deviation Stats Panel (for whale detection) -->
  <div id="stats10sPanel"
    style="margin: 15px 0; padding: 12px 20px; background: white; border-radius: 8px; display: flex; gap: 25px; align-items: center; flex-wrap: wrap;">
    <strong style="font-size: 0.9em;">10s Deviation:</strong>
    <div style="display: flex; gap: 15px; flex-wrap: wrap;">
      <span><strong style="color: #28a745;">Bid Lot:</strong> <span id="stat10sBidLot">0</span></span>
      <span><strong style="color: #dc3545;">Offer Lot:</strong> <span id="stat10sOfferLot">0</span></span>
      <span style="border-left: 1px solid #ccc; padding-left: 15px;"><strong style="color: #28a745;">Bid Freq:</strong>
        <span id="stat10sBidFreq">0</span></span>
      <span><strong style="color: #dc3545;">Offer Freq:</strong> <span id="stat10sOfferFreq">0</span></span>
      <span style="border-left: 1px solid #ccc; padding-left: 15px;"><strong>Totals:</strong> <span
          id="stat10sTotals">-</span></span>
    </div>
  </div>

  <div class="orderbook-container">
    <div class="orderbook-side bid">
      <h3 style="color: #28a745; margin-top: 0">
        <i class="bi bi-arrow-up-circle-fill"></i> BIDS (Buy Orders)
      </h3>
      <table class="orderbook-table">
        <thead>
          <tr>
            <th>Price</th>
            <th>Freq</th>
            <th>Lot</th>
            <th>Change</th>
            <th>30s</th>
            <th>3m</th>
          </tr>
        </thead>
        <tbody id="bidBody">
          <tr>
            <td colspan="6">No data yet...</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="orderbook-side offer">
      <h3 style="color: #dc3545; margin-top: 0">
        <i class="bi bi-arrow-down-circle-fill"></i> OFFERS (Sell Orders)
      </h3>
      <table class="orderbook-table">
        <thead>
          <tr>
            <th>Price</th>
            <th>Freq</th>
            <th>Lot</th>
            <th>Change</th>
            <th>30s</th>
            <th>3m</th>
          </tr>
        </thead>
        <tbody id="offerBody">
          <tr>
            <td colspan="6">No data yet...</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- Volume Histogram Section -->
  <div id="histogramSection"
    style="margin-top: 20px; background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
    <h3 style="margin: 0 0 15px 0; display: flex; align-items: center; gap: 10px;">
      <i class="bi bi-bar-chart-fill"></i> Volume Histogram
      <span style="font-size: 0.7em; color: #888; font-weight: normal;">(Bids ‚Üë / Offers ‚Üì)</span>
    </h3>
    <div id="histogramChart" style="width: 100%; height: 350px;"></div>
    <div style="display: flex; gap: 10px; margin-top: 10px; align-items: center;">
      <span style="font-size: 0.85em; color: #666;">Time Range:</span>
      <button class="btn btn-small btn-secondary histogram-range" data-range="60000"
        onclick="setHistogramRange(60000)">1m</button>
      <button class="btn btn-small btn-secondary histogram-range" data-range="300000"
        onclick="setHistogramRange(300000)">5m</button>
      <button class="btn btn-small btn-secondary histogram-range" data-range="900000"
        onclick="setHistogramRange(900000)">15m</button>
      <button class="btn btn-small btn-primary histogram-range active" data-range="0"
        onclick="setHistogramRange(0)">All</button>
      <span style="margin-left: auto; font-size: 0.85em; color: #888;" id="histogramDataPoints">0 data points</span>
    </div>
  </div>

  <!-- Frequency Histogram Section -->
  <div id="freqHistogramSection"
    style="margin-top: 20px; background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
    <h3 style="margin: 0 0 15px 0; display: flex; align-items: center; gap: 10px;">
      <i class="bi bi-bar-chart-fill"></i> Frequency Histogram
      <span style="font-size: 0.7em; color: #888; font-weight: normal;">(Bids ‚Üë / Offers ‚Üì)</span>
    </h3>
    <div id="freqHistogramChart" style="width: 100%; height: 350px;"></div>
  </div>

  <!-- Confirmation Modal -->
  <div id="confirmModal"
    style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; justify-content: center; align-items: center;">
    <div
      style="background: white; padding: 30px; border-radius: 12px; max-width: 500px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
      <h3 style="margin: 0 0 15px 0; color: #333; display: flex; align-items: center;">
        <span style="font-size: 24px; margin-right: 10px;">‚ö†Ô∏è</span>
        <span>Large File Warning</span>
      </h3>
      <div id="confirmMessage" style="margin: 0 0 25px 0; color: #555; font-size: 14px; line-height: 1.6;"></div>
      <div style="display: flex; gap: 10px; justify-content: flex-end;">
        <button id="confirmCancel" class="btn btn-secondary"
          style="background: #6c757d; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Cancel</button>
        <button id="confirmOk" class="btn btn-success"
          style="background: #28a745; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Continue
          Loading</button>
      </div>
    </div>
  </div>

  <!-- Loading Overlay -->
  <div id="loadingOverlay"
    style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 9999; justify-content: center; align-items: center;">
    <div
      style="background: white; padding: 40px; border-radius: 12px; text-align: center; min-width: 400px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);">
      <div class="spinner"
        style="margin: 0 auto 20px; width: 50px; height: 50px; border: 5px solid #f3f3f3; border-top: 5px solid #007bff; border-radius: 50%; animation: spin 1s linear infinite;">
      </div>
      <h3 id="loadingTitle" style="margin: 0 0 15px 0; color: #333;">Loading Data...</h3>
      <p id="loadingStatus" style="margin: 0 0 20px 0; color: #666; font-size: 14px;">Preparing to load file...</p>
      <div
        style="width: 100%; background: #e0e0e0; border-radius: 10px; overflow: hidden; height: 25px; margin-bottom: 10px;">
        <div id="loadingProgressBar"
          style="width: 0%; height: 100%; background: linear-gradient(90deg, #007bff, #0056b3); transition: width 0.3s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 12px;">
        </div>
      </div>
      <p id="loadingProgressText" style="margin: 0; color: #888; font-size: 13px;">0%</p>
    </div>
  </div>
</div>

<style>
  @keyframes spin {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }
</style>

<script>
  let updateCount = 0;
  let orderbookState = { bids: {}, offers: {} };
  let replayState = "stopped"; // 'stopped', 'running', 'paused'
  let pollInterval = null;
  let renderInterval = null; // Fix: Initialize renderInterval
  let lastBidTimestamp = null;
  let lastOfferTimestamp = null;
  let seekDebounceTimer = null;
  let isSeeking = false;

  // Modal and overlay functions
  function showConfirmModal(message) {
    return new Promise((resolve) => {
      const modal = document.getElementById("confirmModal");
      const messageDiv = document.getElementById("confirmMessage");
      const okBtn = document.getElementById("confirmOk");
      const cancelBtn = document.getElementById("confirmCancel");

      messageDiv.innerHTML = message;
      modal.style.display = "flex";

      function cleanup() {
        modal.style.display = "none";
        okBtn.onclick = null;
        cancelBtn.onclick = null;
      }

      okBtn.onclick = () => {
        cleanup();
        resolve(true);
      };

      cancelBtn.onclick = () => {
        cleanup();
        resolve(false);
      };
    });
  }

  function showLoadingOverlay() {
    document.getElementById("loadingOverlay").style.display = "flex";
  }

  function hideLoadingOverlay() {
    document.getElementById("loadingOverlay").style.display = "none";
  }

  function updateLoadingProgress(percent, current, total) {
    const progressBar = document.getElementById("loadingProgressBar");
    const progressText = document.getElementById("loadingProgressText");
    const statusText = document.getElementById("loadingStatus");

    const roundedPercent = Math.round(percent);
    progressBar.style.width = roundedPercent + "%";
    progressBar.textContent = roundedPercent + "%";
    progressText.textContent = `${roundedPercent}% - ${current.toLocaleString()} / ${total.toLocaleString()} rows`;

    // Estimate time remaining (rough calculation)
    if (window.loadStartTime && percent > 5) {
      const elapsed = (Date.now() - window.loadStartTime) / 1000; // seconds
      const rate = current / elapsed; // rows per second
      const remaining = (total - current) / rate; // seconds
      const mins = Math.floor(remaining / 60);
      const secs = Math.floor(remaining % 60);
      statusText.textContent = `Estimated time remaining: ${mins > 0 ? mins + 'm ' : ''}${secs}s`;
    } else {
      statusText.textContent = `Loading data chunks...`;
    }
  }

  // Client-side replay data
  let replayData = [];
  let currentIndex = 0;
  let isClientSide = true;
  let playbackSpeed = 1.0;
  let lastRenderTime = 0;

  // State
  let minuteBaseState = { bids: {}, offers: {} };
  let currentMinuteIndex = -1;
  let frameChanges = { bids: {}, offers: {} };
  let lastRenderedState = { bids: {}, offers: {} };

  // 30-second tracking
  let state30sAgo = { bids: {}, offers: {} };
  let last30sBoundaryIndex = -1;
  let last30sBoundaryTime = 0;

  // 10-second snapshot tracking for deviation detection
  // Store snapshots of total lots AND freq per side
  let lotSnapshots = []; // [{ts, bidLot, offerLot, bidFreq, offerFreq}]

  // Accumulation with zero-handling: track prices seen in current timestamp batch
  let currentBidTimestamp = 0;
  let currentOfferTimestamp = 0;
  let pricesSeenInBatch = { bids: new Set(), offers: new Set() };

  // Forecasted changes for 3m prediction column
  let forecastedChanges = { bids: {}, offers: {} };

  // Histogram data for Plotly
  let histogramData = []; // [{ts: timestamp, bidTotal: number, offerTotal: number}]
  let histogramRange = 0; // 0 = all data, otherwise ms range
  let histogramInitialized = false;

  // Shared chart config
  const chartConfig = {
    responsive: true,
    displayModeBar: true,
    modeBarButtonsToRemove: ['select2d', 'lasso2d', 'autoScale2d'],
    scrollZoom: true,
    displaylogo: false
  };

  // Initialize Plotly volume histogram
  function initHistogram() {
    const layout = {
      margin: { t: 10, r: 20, b: 40, l: 60 },
      xaxis: {
        type: 'date',
        rangeslider: { visible: true, thickness: 0.1 },
        title: { text: '', standoff: 5 }
      },
      yaxis: {
        title: { text: 'Volume (Lots)', standoff: 10 },
        zeroline: true,
        zerolinewidth: 2,
        zerolinecolor: '#333'
      },
      barmode: 'relative',
      bargap: 0.1,
      hovermode: 'x unified',
      showlegend: true,
      legend: { orientation: 'h', y: 1.02, x: 0.5, xanchor: 'center' },
      dragmode: 'pan'
    };

    const traces = [
      {
        x: [], y: [], type: 'bar', name: 'Bids',
        marker: { color: 'rgba(40, 167, 69, 0.8)' },
        hovertemplate: 'Bid: %{y:,.0f} lots<extra></extra>'
      },
      {
        x: [], y: [], type: 'bar', name: 'Offers',
        marker: { color: 'rgba(220, 53, 69, 0.8)' },
        customdata: [],
        hovertemplate: 'Offer: %{customdata:,.0f} lots<extra></extra>'
      }
    ];

    Plotly.newPlot('histogramChart', traces, layout, chartConfig);
    histogramInitialized = true;
  }

  // Initialize Plotly frequency histogram
  function initFreqHistogram() {
    const layout = {
      margin: { t: 10, r: 20, b: 40, l: 60 },
      xaxis: {
        type: 'date',
        rangeslider: { visible: true, thickness: 0.1 },
        title: { text: '', standoff: 5 }
      },
      yaxis: {
        title: { text: 'Frequency', standoff: 10 },
        zeroline: true,
        zerolinewidth: 2,
        zerolinecolor: '#333'
      },
      barmode: 'relative',
      bargap: 0.1,
      hovermode: 'x unified',
      showlegend: true,
      legend: { orientation: 'h', y: 1.02, x: 0.5, xanchor: 'center' },
      dragmode: 'pan'
    };

    const traces = [
      {
        x: [], y: [], type: 'bar', name: 'Bids',
        marker: { color: 'rgba(40, 167, 69, 0.8)' },
        hovertemplate: 'Bid: %{y:,.0f}<extra></extra>'
      },
      {
        x: [], y: [], type: 'bar', name: 'Offers',
        marker: { color: 'rgba(220, 53, 69, 0.8)' },
        customdata: [],
        hovertemplate: 'Offer: %{customdata:,.0f}<extra></extra>'
      }
    ];

    Plotly.newPlot('freqHistogramChart', traces, layout, chartConfig);
  }

  // Pre-compute all histogram data from loaded replay data
  // Simulates the full orderbook offline and samples every 500ms
  function precomputeHistogram() {
    if (!histogramInitialized || replayData.length === 0) return;

    console.log('[HISTOGRAM] Pre-computing from', replayData.length, 'rows...');
    const startTime = performance.now();

    histogramData = [];
    const tempState = { bids: {}, offers: {} };
    let lastSampleTs = 0;
    let tempBidTimestamp = 0;
    let tempOfferTimestamp = 0;
    let tempPricesSeen = { bids: new Set(), offers: new Set() };

    for (let i = 0; i < replayData.length; i++) {
      const row = replayData[i];
      const ts = row[0];
      const price = row[1];
      const freq = row[2];
      const lot_size = row[3];
      const side = row[4] === 0 ? 'bids' : 'offers';

      // Zero-handling: when timestamp changes for a side, remove unseen prices
      if (side === 'bids' && ts !== tempBidTimestamp) {
        if (tempPricesSeen.bids.size > 0) {
          for (const p of Object.keys(tempState.bids)) {
            if (!tempPricesSeen.bids.has(p)) delete tempState.bids[p];
          }
        }
        tempPricesSeen.bids = new Set();
        tempBidTimestamp = ts;
      } else if (side === 'offers' && ts !== tempOfferTimestamp) {
        if (tempPricesSeen.offers.size > 0) {
          for (const p of Object.keys(tempState.offers)) {
            if (!tempPricesSeen.offers.has(p)) delete tempState.offers[p];
          }
        }
        tempPricesSeen.offers = new Set();
        tempOfferTimestamp = ts;
      }

      tempPricesSeen[side].add(String(price));
      tempState[side][price] = { freq, lot_size };

      // Sample every 500ms of virtual time
      if (ts - lastSampleTs >= 500) {
        const bidTotal = Object.values(tempState.bids).reduce((sum, s) => sum + (s.lot_size || 0), 0);
        const offerTotal = Object.values(tempState.offers).reduce((sum, s) => sum + (s.lot_size || 0), 0);
        const bidFreq = Object.values(tempState.bids).reduce((sum, s) => sum + (s.freq || 0), 0);
        const offerFreq = Object.values(tempState.offers).reduce((sum, s) => sum + (s.freq || 0), 0);
        histogramData.push({ ts, bidTotal, offerTotal, bidFreq, offerFreq });
        lastSampleTs = ts;
      }
    }

    console.log(`[HISTOGRAM] Pre-computed ${histogramData.length} data points in ${(performance.now() - startTime).toFixed(0)}ms`);

    // Lock x-axis to the day's data range
    if (histogramData.length > 0) {
      const firstTs = new Date(histogramData[0].ts);
      const lastTs = new Date(histogramData[histogramData.length - 1].ts);

      Plotly.relayout('histogramChart', {
        'xaxis.range': [firstTs, lastTs],
        'xaxis.autorange': false
      });
      Plotly.relayout('freqHistogramChart', {
        'xaxis.range': [firstTs, lastTs],
        'xaxis.autorange': false
      });
    }

    updateHistogram();
    updateFreqHistogram();
  }

  // Update histogram with current data
  function updateHistogram() {
    if (!histogramInitialized || histogramData.length === 0) return;

    let dataToPlot = histogramData;

    // Apply range filter if set
    if (histogramRange > 0 && histogramData.length > 0) {
      const lastTs = histogramData[histogramData.length - 1].ts;
      const cutoffTs = lastTs - histogramRange;
      dataToPlot = histogramData.filter(d => d.ts >= cutoffTs);
    }

    const times = dataToPlot.map(d => new Date(d.ts));
    const bidTotals = dataToPlot.map(d => d.bidTotal);
    const offerTotals = dataToPlot.map(d => -d.offerTotal); // Negative for downward bars
    const offerCustomdata = dataToPlot.map(d => d.offerTotal); // Positive for hover display

    Plotly.update('histogramChart', {
      x: [times, times],
      y: [bidTotals, offerTotals],
      customdata: [[], offerCustomdata]
    }, {}, [0, 1]);

    document.getElementById('histogramDataPoints').textContent = `${dataToPlot.length.toLocaleString()} data points`;
  }

  // Update frequency histogram with current data
  function updateFreqHistogram() {
    if (!histogramInitialized || histogramData.length === 0) return;

    let dataToPlot = histogramData;

    // Apply same range filter
    if (histogramRange > 0 && histogramData.length > 0) {
      const lastTs = histogramData[histogramData.length - 1].ts;
      const cutoffTs = lastTs - histogramRange;
      dataToPlot = histogramData.filter(d => d.ts >= cutoffTs);
    }

    const times = dataToPlot.map(d => new Date(d.ts));
    const bidFreqs = dataToPlot.map(d => d.bidFreq);
    const offerFreqs = dataToPlot.map(d => -d.offerFreq);
    const offerCustomdata = dataToPlot.map(d => d.offerFreq);

    Plotly.update('freqHistogramChart', {
      x: [times, times],
      y: [bidFreqs, offerFreqs],
      customdata: [[], offerCustomdata]
    }, {}, [0, 1]);
  }

  // Set histogram time range (applies to both charts)
  function setHistogramRange(rangeMs) {
    histogramRange = rangeMs;

    // Update button states
    document.querySelectorAll('.histogram-range').forEach(btn => {
      const btnRange = parseInt(btn.getAttribute('data-range'));
      if (btnRange === rangeMs) {
        btn.classList.remove('btn-secondary');
        btn.classList.add('btn-primary', 'active');
      } else {
        btn.classList.remove('btn-primary', 'active');
        btn.classList.add('btn-secondary');
      }
    });

    updateHistogram();
    updateFreqHistogram();
  }

  async function loadFileList() {
    try {
      const response = await fetch("/api/replay/files");
      const data = await response.json();

      if (data.success) {
        const select = document.getElementById("fileSelect");
        select.innerHTML = '<option value="">-- Select file --</option>';
        data.files.forEach((file) => {
          const option = document.createElement("option");
          option.value = file.path;
          option.textContent = `${file.date} - ${file.ticker}`;
          select.appendChild(option);
        });
      }
    } catch (error) {
      console.error("Error loading files:", error);
    }
  }

  async function loadFile() {
    const select = document.getElementById("fileSelect");
    const csvPath = select.value;

    if (!csvPath) {
      alert("Please select a file");
      return;
    }

    console.log("[LOAD] Loading file:", csvPath);

    try {
      // 1. Get metadata first to check file size
      document.getElementById("status").textContent = "Checking file...";
      const metaResponse = await fetch("/api/replay/metadata", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ csv_path: csvPath }),
      });
      const meta = await metaResponse.json();

      if (!meta.success) {
        throw new Error(meta.error);
      }

      console.log(`[LOAD] File metadata: ${meta.file_size_mb}MB, ~${meta.estimated_rows.toLocaleString()} rows`);

      // 2. Warn if large file (using custom modal to avoid browser blocking)
      if (meta.file_size_mb > 50 || meta.estimated_rows > 2000000) {
        const message = `
          <p style="margin: 0 0 10px 0;"><strong>File:</strong> ${meta.filename}</p>
          <p style="margin: 0 0 10px 0;"><strong>Size:</strong> ${meta.file_size_mb} MB</p>
          <p style="margin: 0 0 10px 0;"><strong>Rows:</strong> ~${meta.estimated_rows.toLocaleString()}</p>
          <p style="margin: 15px 0 0 0; padding-top: 15px; border-top: 1px solid #ddd;">
            This file will take <strong>10-60 seconds</strong> to load.<br>
            Your browser will remain responsive during loading.
          </p>
        `;

        const confirmed = await showConfirmModal(message);

        if (!confirmed) {
          document.getElementById("status").textContent = "Load cancelled by user";
          console.log("[LOAD] User cancelled large file load");
          return;
        }
      }

      // 3. Use chunked loading for large files, direct for small files
      if (meta.estimated_rows > 500000) {
        await loadFileChunked(csvPath, meta);
      } else {
        await loadFileDirect(csvPath);
      }

    } catch (error) {
      alert("Error: " + error.message);
      console.error("[LOAD] Exception:", error);
      document.getElementById("status").textContent = "Error";
      hideLoadingOverlay();
    }
  }

  async function loadFileDirect(csvPath) {
    console.log("[LOAD] Using direct load for small file");
    document.getElementById("status").textContent = "Loading data...";

    // 1. Tell backend to load CSV (needed for parsing)
    const response = await fetch("/api/replay/load", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ csv_path: csvPath }),
    });

    const data = await response.json();

    if (!data.success) {
      throw new Error(data.error);
    }

    // 2. Fetch full dataset for client-side replay
    console.log("[LOAD] Fetching full dataset...");
    const dataResponse = await fetch("/api/replay/data");
    const fullData = await dataResponse.json();

    if (fullData.success) {
      replayData = fullData.rows; // [ts, price, lots, side]
      console.log(`[LOAD] Client-side data loaded: ${replayData.length} rows`);

      isClientSide = true;
      currentIndex = 0;
      replayState = "stopped";

      // Reset state
      orderbookState = { bids: {}, offers: {} };
      forecastedChanges = { bids: {}, offers: {} };
      minuteBaseState = { bids: {}, offers: {} };
      currentMinuteIndex = -1;
      frameChanges = { bids: {}, offers: {} };
      state30sAgo = { bids: {}, offers: {} };
      last30sBoundaryIndex = -1;
      last30sBoundaryTime = 0;
      lotSnapshots = [];
      currentBidTimestamp = 0;
      currentOfferTimestamp = 0;
      pricesSeenInBatch = { bids: new Set(), offers: new Set() };

      // Reset histogram data for new file
      // Pre-compute histogram from full dataset
      precomputeHistogram();

      // Update UI
      document.getElementById("status").textContent = "Ready (Client-Side)";
      document.getElementById("progress").textContent = `0/${replayData.length}`;
      document.getElementById("currentTime").textContent = "--:--:--";
      document.getElementById("updateCount").textContent = "0";

      // Setup scrubber
      const scrubber = document.getElementById("timeScrubber");
      scrubber.max = replayData.length - 1;
      scrubber.value = 0;
      scrubber.disabled = false;
      document.getElementById("scrubberPosition").textContent = `0 / ${replayData.length.toLocaleString()}`;

      // Initial render
      renderFrame(true);

    } else {
      throw new Error("Failed to fetch full data");
    }
  }

  async function loadFileChunked(csvPath, meta) {
    console.log("[LOAD] Using chunked load for large file");

    // Show loading overlay
    showLoadingOverlay();
    window.loadStartTime = Date.now();
    document.getElementById("loadingTitle").textContent = "Loading Large File";
    document.getElementById("loadingStatus").textContent = `Preparing to load ${meta.estimated_rows.toLocaleString()} rows...`;

    // 1. Tell backend to load CSV (for parsing into memory on server)
    const response = await fetch("/api/replay/load", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ csv_path: csvPath }),
    });

    const data = await response.json();

    if (!data.success) {
      hideLoadingOverlay();
      throw new Error(data.error);
    }

    // 2. Load data in chunks from server
    const CHUNK_SIZE = 100000; // 100k rows per chunk
    let offset = 0;
    let allRows = [];
    const totalRows = data.total_rows;

    while (true) {
      const chunkResponse = await fetch(
        `/api/replay/data/chunked?offset=${offset}&chunk_size=${CHUNK_SIZE}`
      );
      const chunkData = await chunkResponse.json();

      if (!chunkData.success) {
        hideLoadingOverlay();
        throw new Error(chunkData.error);
      }

      allRows = allRows.concat(chunkData.rows);

      // Update progress
      const progress = (allRows.length / totalRows) * 100;
      updateLoadingProgress(progress, allRows.length, totalRows);

      console.log(`[LOAD] Loaded ${allRows.length} / ${totalRows} rows (${Math.round(progress)}%)`);

      if (!chunkData.has_more) break;
      offset += CHUNK_SIZE;

      // Yield to browser to stay responsive
      await new Promise(r => setTimeout(r, 10));
    }

    // 3. Initialize with loaded data
    replayData = allRows;
    console.log(`[LOAD] Chunked load complete: ${replayData.length} rows`);

    isClientSide = true;
    currentIndex = 0;
    replayState = "stopped";

    // Reset state
    orderbookState = { bids: {}, offers: {} };
    minuteBaseState = { bids: {}, offers: {} };
    currentMinuteIndex = -1;
    frameChanges = { bids: {}, offers: {} };
    state30sAgo = { bids: {}, offers: {} };
    last30sBoundaryIndex = -1;
    last30sBoundaryTime = 0;
    lotSnapshots = [];
    currentBidTimestamp = 0;
    currentOfferTimestamp = 0;
    pricesSeenInBatch = { bids: new Set(), offers: new Set() };

    forecastedChanges = { bids: {}, offers: {} };

    // Pre-compute histogram from full dataset
    precomputeHistogram();
    document.getElementById("status").textContent = "Ready (Client-Side)";
    document.getElementById("progress").textContent = `0/${replayData.length}`;
    document.getElementById("currentTime").textContent = "--:--:--";
    document.getElementById("updateCount").textContent = "0";

    // Setup scrubber
    const scrubber = document.getElementById("timeScrubber");
    scrubber.max = replayData.length - 1;
    scrubber.value = 0;
    scrubber.disabled = false;
    document.getElementById("scrubberPosition").textContent = `0 / ${replayData.length.toLocaleString()}`;

    // Hide loading overlay
    hideLoadingOverlay();

    // Initial render
    renderFrame(true);
  }

  function startReplay() {
    const speed = playbackSpeed || 10;  // Use current playbackSpeed or default to 10

    if (isClientSide) {
      console.log(`[START] Client-side replay @ ${speed}x`);
      replayState = "running";
      lastRenderTime = performance.now();

      // Update UI
      updateControlsRunning();

      // Start loop
      if (renderInterval) cancelAnimationFrame(renderInterval);
      renderInterval = requestAnimationFrame(gameLoop);

      return;
    }

    // Fallback to Server-Side
    startReplayServer(speed);
  }

  function pauseReplay() {
    if (isClientSide) {
      console.log("[PAUSE] Client-side paused");
      replayState = "paused";
      cancelAnimationFrame(renderInterval);
      updateControlsPaused();
      return;
    }
    pauseReplayServer();
  }

  function resumeReplay() {
    if (isClientSide) {
      console.log("[RESUME] Client-side resumed");
      replayState = "running";
      lastRenderTime = performance.now();
      renderInterval = requestAnimationFrame(gameLoop);
      updateControlsRunning();
      return;
    }
    resumeReplayServer();
  }

  function stopReplay() {
    if (isClientSide) {
      console.log("[STOP] Client-side stopped");
      replayState = "stopped";
      cancelAnimationFrame(renderInterval);

      currentIndex = 0;
      orderbookState = { bids: {}, offers: {} };
      forecastedChanges = { bids: {}, offers: {} };
      minuteBaseState = { bids: {}, offers: {} };
      currentMinuteIndex = -1;
      frameChanges = { bids: {}, offers: {} };
      state30sAgo = { bids: {}, offers: {} };
      last30sBoundaryIndex = -1;
      last30sBoundaryTime = 0;
      lotSnapshots = [];
      currentBidTimestamp = 0;
      currentOfferTimestamp = 0;
      pricesSeenInBatch = { bids: new Set(), offers: new Set() };

      // Note: histogram data is pre-computed on file load, no reset needed

      renderFrame(true); // Reset view
      updateControlsStopped();
      return;
    }
    stopReplayServer();
  }

  function updateControlsRunning() {
    document.getElementById("startBtn").disabled = true;
    document.getElementById("pauseBtn").disabled = false;
    document.getElementById("pauseBtn").style.display = "inline-block";
    document.getElementById("resumeBtn").disabled = true;
    document.getElementById("resumeBtn").style.display = "none";
    document.getElementById("stopBtn").disabled = false;
    document.getElementById("fileSelect").disabled = true;
    document.getElementById("timeScrubber").disabled = false;
    document.getElementById("status").textContent = "RUNNING (Client)";
    document.getElementById("speed").textContent = playbackSpeed + "x";
  }

  function updateControlsPaused() {
    document.getElementById("pauseBtn").disabled = true;
    document.getElementById("pauseBtn").style.display = "none";
    document.getElementById("resumeBtn").disabled = false;
    document.getElementById("resumeBtn").style.display = "inline-block";
    document.getElementById("stopBtn").disabled = false;
    document.getElementById("status").textContent = "PAUSED (Client)";
  }

  function updateControlsStopped() {
    document.getElementById("startBtn").disabled = false;
    document.getElementById("pauseBtn").disabled = true;
    document.getElementById("pauseBtn").style.display = "inline-block";
    document.getElementById("resumeBtn").disabled = true;
    document.getElementById("resumeBtn").style.display = "none";
    document.getElementById("stopBtn").disabled = true;
    document.getElementById("fileSelect").disabled = false;
    document.getElementById("status").textContent = "STOPPED (Client)";
    document.getElementById("speed").textContent = "1.0x";

    // Clear tables
    document.getElementById("bidBody").innerHTML = '<tr><td colspan="4" style="text-align:center; color:#888;">Stopped</td></tr>';
    document.getElementById("offerBody").innerHTML = '<tr><td colspan="4" style="text-align:center; color:#888;">Stopped</td></tr>';
  }

  function setSpeed(speed) {
    if (!speed) speed = playbackSpeed; // Default to current

    playbackSpeed = speed;
    document.getElementById("speed").textContent = `${speed}x`;

    // Update button states
    document.querySelectorAll('.speed-btn').forEach(btn => {
      const btnSpeed = parseInt(btn.getAttribute('data-speed'));
      if (btnSpeed === speed) {
        btn.classList.add('active');
        btn.classList.remove('btn-secondary');
        btn.classList.add('btn-primary');
      } else {
        btn.classList.remove('active');
        btn.classList.remove('btn-primary');
        btn.classList.add('btn-secondary');
      }
    });

    console.log(`[SPEED] Set to ${speed}x`);
  }

  // Go-To Time function: binary search for target time
  function gotoTime() {
    const timeInput = document.getElementById("gotoTimeInput").value;
    if (!timeInput) {
      alert("Please enter a time (HH:MM:SS)");
      return;
    }

    if (replayData.length === 0) {
      alert("Please load a file first");
      return;
    }

    // Parse target time - get date from first row and combine with input time
    const firstTs = new Date(replayData[0][0]);
    const [hours, minutes, seconds] = timeInput.split(':').map(Number);

    // Create target date using same date as data
    const targetDate = new Date(firstTs);
    targetDate.setHours(hours, minutes, seconds || 0, 0);
    const targetMs = targetDate.getTime();

    console.log(`[GOTO] Seeking to ${timeInput} (${targetMs})`);

    // Binary search for closest row
    let left = 0;
    let right = replayData.length - 1;
    let closest = 0;

    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const midTs = replayData[mid][0];

      if (midTs === targetMs) {
        closest = mid;
        break;
      } else if (midTs < targetMs) {
        closest = mid;
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }

    console.log(`[GOTO] Found row ${closest} (ts: ${new Date(replayData[closest][0]).toLocaleTimeString()})`);

    // Set scrubber and seek
    document.getElementById("timeScrubber").value = closest;
    seekToPosition();
  }

  // Scrubber event handlers with debouncing
  function onScrubberInput() {
    // Only update display, don't seek yet
    updateScrubberDisplay();
  }

  function onScrubberChange() {
    // Debounce the actual seek operation
    clearTimeout(seekDebounceTimer);
    seekDebounceTimer = setTimeout(() => {
      seekToPosition();
    }, 50); // 50ms debounce
  }

  async function seekToPosition() {
    const scrubber = document.getElementById("timeScrubber");
    const position = parseInt(scrubber.value);

    if (!isClientSide) {
      seekToPositionServer(position);
      return;
    }

    // Prevent concurrent seeks
    if (isSeeking) {
      console.log("[SEEK] Already seeking, ignoring...");
      return;
    }

    isSeeking = true;

    // Pause if running
    const wasRunning = replayState === "running";
    if (wasRunning) {
      replayState = "paused";
      cancelAnimationFrame(renderInterval);
    }

    // Show seeking indicator
    const statusEl = document.getElementById("status");
    const originalStatus = statusEl.textContent;
    statusEl.textContent = "Seeking...";

    try {
      // Logic: If moving backwards, full reset
      if (position < currentIndex) {
        currentIndex = 0;
        orderbookState = { bids: {}, offers: {} };
        forecastedChanges = { bids: {}, offers: {} };
        minuteBaseState = { bids: {}, offers: {} };
        currentMinuteIndex = -1;
        state30sAgo = { bids: {}, offers: {} };
        last30sBoundaryIndex = -1;
        last30sBoundaryTime = 0;
        lotSnapshots = [];
        currentBidTimestamp = 0;
        currentOfferTimestamp = 0;
        pricesSeenInBatch = { bids: new Set(), offers: new Set() };
        // Histogram data is pre-computed, no reset needed on seek
      }

      // Forward replay from currentIndex to position
      const targetIndex = Math.min(position, replayData.length - 1);
      const CHUNK_SIZE = 10000; // Process 10k rows at a time

      // Async chunked processing to avoid blocking UI
      while (currentIndex < targetIndex) {
        const chunkEnd = Math.min(currentIndex + CHUNK_SIZE, targetIndex);

        // Process chunk synchronously
        for (let i = currentIndex; i < chunkEnd; i++) {
          processRow(replayData[i]);
        }

        currentIndex = chunkEnd;

        // Yield to UI thread every chunk
        if (currentIndex < targetIndex) {
          await new Promise(r => setTimeout(r, 0));
        }
      }

      // Reset instantaneous frame changes as we just jumped
      frameChanges = { bids: {}, offers: {} };

      // Sync virtualTime
      if (currentIndex < replayData.length) {
        window.virtualTime = replayData[currentIndex][0];
      }

      // Update scrubber UI
      document.getElementById("scrubberPosition").textContent = `${currentIndex.toLocaleString()} / ${replayData.length.toLocaleString()}`;

      // Render the frame
      renderFrame(true);

      // Restore status
      statusEl.textContent = wasRunning ? "RUNNING (Client)" : "Ready (Client-Side)";

      // Resume if was running
      if (wasRunning) {
        replayState = "running";
        lastRenderTime = performance.now();
        renderInterval = requestAnimationFrame(gameLoop);
      }
    } finally {
      isSeeking = false;
    }
  }

  // --- Client-Side Loop ---

  // Scans forward from 'startIdx' to find the state at 'endTimestamp'
  // Returns the difference between State@EndTime and current OrderbookState
  function calculateForecast2(startIdx, endTimestamp) {
    let tempParams = { bids: {}, offers: {} };

    // Scan forward (limited to prevent performance issues)
    const MAX_SCAN_ROWS = 50000;
    const scanLimit = Math.min(startIdx + MAX_SCAN_ROWS, replayData.length);

    let i = startIdx;
    while (i < scanLimit) {
      const row = replayData[i];
      if (row[0] >= endTimestamp) break; // Reached end of window

      const price = row[1];
      const freq = row[2];
      const lot_size = row[3];
      const side = row[4] === 0 ? 'bids' : 'offers';

      tempParams[side][price] = { freq, lot_size };
      i++;
    }

    const diffs = { bids: {}, offers: {} };

    // Merge keys to find all prices
    const allBids = new Set([
      ...Object.keys(orderbookState.bids),
      ...Object.keys(tempParams.bids)
    ]);
    const allOffers = new Set([
      ...Object.keys(orderbookState.offers),
      ...Object.keys(tempParams.offers)
    ]);

    allBids.forEach(p => {
      const endState = tempParams.bids[p] || { freq: 0, lot_size: 0 };
      const startState = orderbookState.bids[p] || { freq: 0, lot_size: 0 };
      const endVal = tempParams.bids[p] ? endState.lot_size : (orderbookState.bids[p]?.lot_size || 0);
      const startVal = startState.lot_size || 0;
      if (endVal - startVal !== 0) {
        diffs.bids[p] = endVal - startVal;
      }
    });

    allOffers.forEach(p => {
      const endState = tempParams.offers[p] || { freq: 0, lot_size: 0 };
      const startState = orderbookState.offers[p] || { freq: 0, lot_size: 0 };
      const endVal = tempParams.offers[p] ? endState.lot_size : (orderbookState.offers[p]?.lot_size || 0);
      const startVal = startState.lot_size || 0;
      if (endVal - startVal !== 0) {
        diffs.offers[p] = endVal - startVal;
      }
    });

    return diffs;
  }

  function processRow(row) {
    // row: [ts, price, freq, lot_size, side]
    const ts = row[0];
    const price = row[1];
    const freq = row[2];
    const lot_size = row[3];
    const side = row[4] === 0 ? 'bids' : 'offers';

    // 1. Accumulation with zero-handling: When timestamp changes for this side,
    //    set all prices NOT in the new batch to 0 (they've been removed)
    if (side === 'bids' && ts !== currentBidTimestamp) {
      // Save snapshot for 10s deviation BEFORE changes
      if (currentBidTimestamp > 0) {
        const bidLot = Object.values(orderbookState.bids).reduce((sum, s) => sum + (s.lot_size || 0), 0);
        const offerLot = Object.values(orderbookState.offers).reduce((sum, s) => sum + (s.lot_size || 0), 0);
        const bidFreq = Object.values(orderbookState.bids).reduce((sum, s) => sum + (s.freq || 0), 0);
        const offerFreq = Object.values(orderbookState.offers).reduce((sum, s) => sum + (s.freq || 0), 0);
        lotSnapshots.push({ ts: currentBidTimestamp, bidLot, offerLot, bidFreq, offerFreq });
      }

      // Zero out prices not seen in the previous batch (they've been removed)
      if (pricesSeenInBatch.bids.size > 0) {
        for (const p of Object.keys(orderbookState.bids)) {
          if (!pricesSeenInBatch.bids.has(p)) {
            // Price was removed - record change and delete
            const oldLot = orderbookState.bids[p].lot_size || 0;
            if (oldLot > 0) {
              frameChanges.bids[p] = (frameChanges.bids[p] || 0) - oldLot;
            }
            delete orderbookState.bids[p];
          }
        }
      }
      pricesSeenInBatch.bids = new Set();
      currentBidTimestamp = ts;
    } else if (side === 'offers' && ts !== currentOfferTimestamp) {
      // Zero out prices not seen in the previous batch
      if (pricesSeenInBatch.offers.size > 0) {
        for (const p of Object.keys(orderbookState.offers)) {
          if (!pricesSeenInBatch.offers.has(p)) {
            const oldLot = orderbookState.offers[p].lot_size || 0;
            if (oldLot > 0) {
              frameChanges.offers[p] = (frameChanges.offers[p] || 0) - oldLot;
            }
            delete orderbookState.offers[p];
          }
        }
      }
      pricesSeenInBatch.offers = new Set();
      currentOfferTimestamp = ts;
    }

    // Mark this price as seen in current batch
    pricesSeenInBatch[side].add(String(price));

    // 2. Check 3-Minute Boundary (for 3m forecast)
    const bucketIndex = Math.floor(ts / 180000); // 3 minutes

    if (bucketIndex > currentMinuteIndex) {
      // New 3m bucket started!
      const bucketEndTime = (bucketIndex + 1) * 180000;

      // Update State
      minuteBaseState = {
        bids: JSON.parse(JSON.stringify(orderbookState.bids)),
        offers: JSON.parse(JSON.stringify(orderbookState.offers))
      };
      currentMinuteIndex = bucketIndex;

      // Calculate Forecast
      forecastedChanges = calculateForecast2(currentIndex, bucketEndTime);
    }

    // 3. Check 30-Second Boundary (for 30s change column)
    const bucket30sIndex = Math.floor(ts / 30000); // 30 seconds

    if (bucket30sIndex > last30sBoundaryIndex) {
      // New 30s bucket - save current state as "30s ago" reference
      state30sAgo = {
        bids: JSON.parse(JSON.stringify(orderbookState.bids)),
        offers: JSON.parse(JSON.stringify(orderbookState.offers))
      };
      last30sBoundaryIndex = bucket30sIndex;
      last30sBoundaryTime = ts;
    }

    // 4. Track Change (Instantaneous / Frame-based) - based on lot_size
    const oldState = orderbookState[side][price] || { freq: 0, lot_size: 0 };
    const lot_diff = lot_size - oldState.lot_size;

    if (lot_diff !== 0) {
      frameChanges[side][price] = (frameChanges[side][price] || 0) + lot_diff;
    }

    // 5. Update Actual State
    orderbookState[side][price] = {
      freq: freq,
      lot_size: lot_size
    };
  }

  function gameLoop(timestamp) {
    if (replayState !== "running") return;

    const elapsed = timestamp - lastRenderTime;
    lastRenderTime = timestamp;

    if (currentIndex >= replayData.length) {
      stopReplay();
      return;
    }

    const currentRow = replayData[currentIndex];
    const currentTs = currentRow[0];

    if (!window.virtualTime) window.virtualTime = currentTs;
    window.virtualTime += (elapsed * playbackSpeed);

    // Process rows
    let updates = 0;
    while (currentIndex < replayData.length) {
      const row = replayData[currentIndex];
      if (row[0] > window.virtualTime) break;

      processRow(row);

      currentIndex++;
      updates++;

      if (updates > 20000) { // Safety cap
        window.virtualTime = row[0];
        break;
      }
    }

    // Render logic
    renderFrame();

    // Important: We reset frame changes AFTER render, but wait, 
    // if we reset immediately, the user sees it for 0ms?
    // No, renderFrame updates the DOM. The DOM persists until next update.
    // So resetting here is correct for the NEXT frame to accumulate new changes.
    frameChanges = { bids: {}, offers: {} };
    renderInterval = requestAnimationFrame(gameLoop);
  }

  function renderFrame(force = false) {
    // Update basic stats
    document.getElementById("progress").textContent = `${currentIndex}/${replayData.length}`;
    let currentTs = 0;
    if (replayData.length > 0 && currentIndex > 0) {
      currentTs = replayData[currentIndex - 1][0];
      const ts = new Date(currentTs);
      document.getElementById("currentTime").textContent = ts.toLocaleTimeString("en-US", { hour12: false });
    }

    // Update Scrubber (visually only)
    document.getElementById("timeScrubber").value = currentIndex;

    // Purge old snapshots (older than 10s)
    const cutoffTime = currentTs - 10000;
    lotSnapshots = lotSnapshots.filter(s => s.ts >= cutoffTime);

    // Histogram data is pre-computed on file load, no streaming collection needed

    // Calculate current totals (lot and freq)
    const currentBidLot = Object.values(orderbookState.bids).reduce((sum, s) => sum + (s.lot_size || 0), 0);
    const currentOfferLot = Object.values(orderbookState.offers).reduce((sum, s) => sum + (s.lot_size || 0), 0);
    const currentBidFreq = Object.values(orderbookState.bids).reduce((sum, s) => sum + (s.freq || 0), 0);
    const currentOfferFreq = Object.values(orderbookState.offers).reduce((sum, s) => sum + (s.freq || 0), 0);

    // Calculate 10s average from snapshots (only last 10 seconds)
    // For slow stocks with large gaps between timestamps, use current values as baseline
    let avgBidLot = currentBidLot, avgOfferLot = currentOfferLot;
    let avgBidFreq = currentBidFreq, avgOfferFreq = currentOfferFreq;
    if (lotSnapshots.length > 0) {
      avgBidLot = lotSnapshots.reduce((sum, s) => sum + (s.bidLot || 0), 0) / lotSnapshots.length;
      avgOfferLot = lotSnapshots.reduce((sum, s) => sum + (s.offerLot || 0), 0) / lotSnapshots.length;
      avgBidFreq = lotSnapshots.reduce((sum, s) => sum + (s.bidFreq || 0), 0) / lotSnapshots.length;
      avgOfferFreq = lotSnapshots.reduce((sum, s) => sum + (s.offerFreq || 0), 0) / lotSnapshots.length;
    }

    // Calculate deviation from 10s average
    const bidLotDev = currentBidLot - avgBidLot;
    const offerLotDev = currentOfferLot - avgOfferLot;
    const bidFreqDev = currentBidFreq - avgBidFreq;
    const offerFreqDev = currentOfferFreq - avgOfferFreq;

    // Update 10s stats display elements
    const bidLotEl = document.getElementById("stat10sBidLot");
    const offerLotEl = document.getElementById("stat10sOfferLot");
    const bidFreqEl = document.getElementById("stat10sBidFreq");
    const offerFreqEl = document.getElementById("stat10sOfferFreq");
    const totalsEl = document.getElementById("stat10sTotals");

    // Bid lot deviation - positive means more lots than 10s average (accumulation)
    bidLotEl.textContent = bidLotDev >= 0 ? `+${Math.round(bidLotDev).toLocaleString()}` : Math.round(bidLotDev).toLocaleString();
    bidLotEl.style.color = bidLotDev > 0 ? '#28a745' : (bidLotDev < 0 ? '#dc3545' : '#666');

    // Offer lot deviation - positive means more lots than average (selling pressure)
    offerLotEl.textContent = offerLotDev >= 0 ? `+${Math.round(offerLotDev).toLocaleString()}` : Math.round(offerLotDev).toLocaleString();
    offerLotEl.style.color = offerLotDev > 0 ? '#dc3545' : (offerLotDev < 0 ? '#28a745' : '#666');

    // Bid freq deviation
    bidFreqEl.textContent = bidFreqDev >= 0 ? `+${Math.round(bidFreqDev).toLocaleString()}` : Math.round(bidFreqDev).toLocaleString();
    bidFreqEl.style.color = bidFreqDev > 0 ? '#28a745' : (bidFreqDev < 0 ? '#dc3545' : '#666');

    // Offer freq deviation
    offerFreqEl.textContent = offerFreqDev >= 0 ? `+${Math.round(offerFreqDev).toLocaleString()}` : Math.round(offerFreqDev).toLocaleString();
    offerFreqEl.style.color = offerFreqDev > 0 ? '#dc3545' : (offerFreqDev < 0 ? '#28a745' : '#666');

    // Show current totals for reference
    totalsEl.innerHTML = `L: <b>${currentBidLot.toLocaleString()}</b>/<b>${currentOfferLot.toLocaleString()}</b> | F: <b>${currentBidFreq.toLocaleString()}</b>/<b>${currentOfferFreq.toLocaleString()}</b>`;
    totalsEl.style.color = '#666';

    // Sort and render top 20 (no stale price detection - prices are now overwritten per timestamp)
    let bids = Object.entries(orderbookState.bids)
      .map(([p, state]) => ({
        price: parseFloat(p),
        freq: state.freq || 0,
        lot_size: state.lot_size || 0
      }))
      .filter(x => x.lot_size > 0)
      .sort((a, b) => b.price - a.price)
      .slice(0, 20);

    let offers = Object.entries(orderbookState.offers)
      .map(([p, state]) => ({
        price: parseFloat(p),
        freq: state.freq || 0,
        lot_size: state.lot_size || 0
      }))
      .filter(x => x.lot_size > 0)
      .sort((a, b) => a.price - b.price)
      .slice(0, 20);

    // Update HTML
    const bidBody = document.getElementById("bidBody");
    bidBody.innerHTML = bids.map(row => {
      const changeFrame = frameChanges.bids[row.price] || 0;
      const state30s = state30sAgo.bids[row.price] || { lot_size: 0 };
      const change30s = row.lot_size - (state30s.lot_size || 0);
      const change3m = forecastedChanges.bids[row.price] || 0;

      return `<tr>
            <td>${row.price.toFixed(0)}</td>
            <td>${row.freq.toLocaleString()}</td>
            <td>${row.lot_size.toLocaleString()}</td>
            <td>${formatChange(changeFrame)}</td>
            <td style="font-size:0.85em;">${formatChange(change30s)}</td>
            <td style="font-size:0.9em; font-weight:bold;">${formatChange(change3m)}</td>
      </tr>`;
    }).join("");

    const offerBody = document.getElementById("offerBody");
    offerBody.innerHTML = offers.map(row => {
      const changeFrame = frameChanges.offers[row.price] || 0;
      const state30s = state30sAgo.offers[row.price] || { lot_size: 0 };
      const change30s = row.lot_size - (state30s.lot_size || 0);
      const change3m = forecastedChanges.offers[row.price] || 0;

      return `<tr>
            <td>${row.price.toFixed(0)}</td>
            <td>${row.freq.toLocaleString()}</td>
            <td>${row.lot_size.toLocaleString()}</td>
            <td>${formatChange(changeFrame)}</td>
            <td style="font-size:0.85em;">${formatChange(change30s)}</td>
            <td style="font-size:0.9em; font-weight:bold;">${formatChange(change3m)}</td>
      </tr>`;
    }).join("");

    document.getElementById("levels").textContent = bids.length + offers.length;

    // Histogram is pre-computed on file load, no per-frame update needed
  }

  // --- Legacy Server Calls (Renamed) ---

  async function startReplayServer(speed) {
    console.log(`[START] Starting replay with speed ${speed}x`);
    const response = await fetch("/api/replay/start", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ speed_multiplier: speed }),
    });
    // ... (rest of old start logic if needed, but we rely on client side now)
    // For brevity, assuming client side works. logic is same as before.
    const data = await response.json();
    if (data.success) {
      replayState = "running";
      updateControlsRunning();
    }
  }

  async function pauseReplayServer() {
    const response = await fetch("/api/replay/pause", { method: "POST" });
    const data = await response.json();
    if (data.success) { replayState = "paused"; updateControlsPaused(); }
  }

  async function resumeReplayServer() {
    const response = await fetch("/api/replay/resume", { method: "POST" });
    const data = await response.json();
    if (data.success) { replayState = "running"; updateControlsRunning(); }
  }

  async function stopReplayServer() {
    await fetch("/api/replay/stop", { method: "POST" });
    replayState = "stopped";
    updateControlsStopped();
  }

  async function setSpeedServer(speed) {
    await fetch("/api/replay/speed", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ multiplier: speed }),
    });
  }

  async function seekToPositionServer(position) {
    await fetch("/api/replay/seek", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ position: position }),
    });
  }

  async function updateOrderbook() {
    // Only fetch API if running (not stopped or paused) AND not client-side
    if (replayState !== "running" || isClientSide) {
      return;
    }

    try {
      const response = await fetch("/api/replay/orderbook");
      const data = await response.json();

      if (data.success) {
        // Update timestamp display
        if (data.current_timestamp) {
          const timestamp = new Date(data.current_timestamp);
          const timeStr = timestamp.toLocaleTimeString("en-US", {
            hour12: false,
          });
          document.getElementById("currentTime").textContent = timeStr;
        }

        const hasData = (data.bids && data.bids.length > 0) || (data.offers && data.offers.length > 0);

        if (hasData) {
          updateCount++;
          document.getElementById("updateCount").textContent = updateCount.toLocaleString();
        }

        // Update BID table
        const bidBody = document.getElementById("bidBody");
        if (data.bids && data.bids.length > 0) {
          bidBody.innerHTML = data.bids.map((row) => {
            return `<tr>
                <td>${row.price.toFixed(0)}</td>
                <td>${row.lots.toLocaleString()}</td>
                <td><span style="color:#888;">0</span></td>
                <td style="color:#888;">-</td>
              </tr>`;
          }).join("");
        }

        // Update OFFER table
        const offerBody = document.getElementById("offerBody");
        if (data.offers && data.offers.length > 0) {
          offerBody.innerHTML = data.offers.map((row) => {
            return `<tr>
                <td>${row.price.toFixed(0)}</td>
                <td>${row.lots.toLocaleString()}</td>
                <td><span style="color:#888;">0</span></td>
                <td style="color:#888;">-</td>
              </tr>`;
          }).join("");
        }

        if (data.running !== undefined) {
          document.getElementById("progress").textContent = `${data.index || 0}/${data.total_rows || 0}`;
        }
      }
    } catch (error) {
      console.error("Error updating orderbook:", error);
    }
  }

  function formatChange(change) {
    if (change === 0) return '<span style="color:#888;">0</span>';
    if (change > 0)
      return `<span class="change-positive">+${change.toLocaleString()}</span>`;
    return `<span class="change-negative">${change.toLocaleString()}</span>`;
  }

  function updateScrubberDisplay() {
    const scrubber = document.getElementById("timeScrubber");
    const max = parseInt(scrubber.max);
    const value = parseInt(scrubber.value);
    document.getElementById(
      "scrubberPosition",
    ).textContent = `${value.toLocaleString()} / ${max.toLocaleString()}`;
  }

  // Poll for updates continuously (but updateOrderbook checks replayState)
  pollInterval = setInterval(updateOrderbook, 100);

  // Initial load
  loadFileList();

  // Initialize histogram
  initHistogram();
  initFreqHistogram();

  console.log("[INIT] Simple orderbook view initialized");
</script>
{% endblock %}