{% extends "base.html" %} {% block title %}Simple Orderbook View{% endblock %}
{% block content %}
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.0/font/bootstrap-icons.css"
/>

<style>
  .orderbook-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-top: 20px;
  }

  .orderbook-side {
    background: white;
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .orderbook-side.bid {
    border-left: 4px solid #28a745;
  }

  .orderbook-side.offer {
    border-left: 4px solid #dc3545;
  }

  .orderbook-table {
    width: 100%;
    font-family: "Courier New", monospace;
    font-size: 14px;
  }

  .orderbook-table th {
    background: #f8f9fa;
    padding: 10px;
    text-align: right;
    font-weight: 600;
    border-bottom: 2px solid #dee2e6;
  }

  .orderbook-table td {
    padding: 8px 10px;
    text-align: right;
    border-bottom: 1px solid #f0f0f0;
  }

  .orderbook-table tr:hover {
    background: #f8f9fa;
  }

  .change-positive {
    color: #28a745;
    font-weight: bold;
  }

  .change-negative {
    color: #dc3545;
    font-weight: bold;
  }

  .live-indicator {
    display: inline-block;
    width: 10px;
    height: 10px;
    background: #28a745;
    border-radius: 50%;
    animation: pulse 1s infinite;
  }

  @keyframes pulse {
    0%,
    100% {
      opacity: 1;
    }
    50% {
      opacity: 0.3;
    }
  }

  .status-bar {
    background: white;
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .btn {
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: 600;
    margin: 0 5px;
  }

  .btn-success {
    background: #28a745;
    color: white;
  }
  .btn-danger {
    background: #dc3545;
    color: white;
  }
  .btn-warning {
    background: #ffc107;
    color: #000;
  }
  .btn-primary {
    background: #007bff;
    color: white;
  }

  .btn:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
</style>

<div class="container">
  <h1 class="mb-4">
    <i class="bi bi-bar-chart-line"></i> Simple Orderbook View
    <span class="live-indicator"></span>
  </h1>

  <div class="alert alert-info">
    <strong>üìä Real-time Orderbook Ladder</strong> - This view updates every
    100ms with live market data
  </div>

  <div class="status-bar">
    <div>
      <strong>Status:</strong> <span id="status">Loading...</span> |
      <strong>Time:</strong> <span id="currentTime">--:--:--</span> |
      <strong>Updates:</strong> <span id="updateCount">0</span> |
      <strong>Speed:</strong> <span id="speed">1.0x</span> |
      <strong>Progress:</strong> <span id="progress">0/0</span> |
      <strong>Levels:</strong> <span id="levels">0</span>
    </div>
    <div>
      <select
        id="fileSelect"
        class="form-control"
        style="display: inline-block; width: auto; margin-right: 10px"
      >
        <option value="">Loading files...</option>
      </select>
      <button class="btn btn-primary" onclick="loadFile()">Load</button>
      <button class="btn btn-success" id="startBtn" onclick="startReplay()">
        ‚ñ∂ Start
      </button>
      <button
        class="btn btn-warning"
        id="pauseBtn"
        onclick="pauseReplay()"
        disabled
      >
        ‚è∏ Pause
      </button>
      <button
        class="btn btn-success"
        id="resumeBtn"
        onclick="resumeReplay()"
        disabled
        style="display: none"
      >
        ‚ñ∂ Resume
      </button>
      <button
        class="btn btn-danger"
        id="stopBtn"
        onclick="stopReplay()"
        disabled
      >
        ‚èπ Stop
      </button>
      <input
        type="number"
        id="speedInput"
        value="10"
        min="1"
        max="100"
        style="width: 60px; margin-left: 10px"
      />
      <button class="btn btn-primary" onclick="setSpeed()">Set Speed</button>
    </div>
  </div>

  <div
    style="margin: 20px 0; padding: 15px; background: white; border-radius: 8px"
  >
    <div style="display: flex; align-items: center; gap: 10px">
      <strong>Timeline:</strong>
      <input
        type="range"
        id="timeScrubber"
        min="0"
        max="100"
        value="0"
        disabled
        style="flex: 1; height: 8px; cursor: pointer"
        oninput="updateScrubberDisplay()"
        onchange="seekToPosition()"
      />
      <span
        id="scrubberPosition"
        style="min-width: 80px; font-family: monospace"
        >0 / 0</span
      >
    </div>
  </div>

  <div class="orderbook-container">
    <div class="orderbook-side bid">
      <h3 style="color: #28a745; margin-top: 0">
        <i class="bi bi-arrow-up-circle-fill"></i> BIDS (Buy Orders)
      </h3>
      <table class="orderbook-table">
        <thead>
          <tr>
            <th>Price</th>
            <th>Lots</th>
            <th>Change</th>
            <th>10s</th>
          </tr>
        </thead>
        <tbody id="bidBody">
          <tr>
            <td colspan="4">No data yet...</td>
          </tr>
        </tbody>
      </table>
    </div>

    <div class="orderbook-side offer">
      <h3 style="color: #dc3545; margin-top: 0">
        <i class="bi bi-arrow-down-circle-fill"></i> OFFERS (Sell Orders)
      </h3>
      <table class="orderbook-table">
        <thead>
          <tr>
            <th>Price</th>
            <th>Lots</th>
            <th>Change</th>
            <th>10s</th>
          </tr>
        </thead>
        <tbody id="offerBody">
          <tr>
            <td colspan="4">No data yet...</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>

<script>
  let updateCount = 0;
  let orderbookState = { bids: {}, offers: {} };
  let replayState = "stopped"; // 'stopped', 'running', 'paused'
  let pollInterval = null;
  let renderInterval = null; // Fix: Initialize renderInterval
  let lastBidTimestamp = null;
  let lastOfferTimestamp = null;

  // Client-side replay data
  let replayData = []; 
  let currentIndex = 0;
  let isClientSide = true; 
  let playbackSpeed = 1.0;
  let lastRenderTime = 0;

  // 10-second window tracking (per-price)
  let changeWindow = []; // Array of {timestamp, price, side, change}
  const WINDOW_SIZE_MS = 10000; // 10 seconds
  let priceChangeCache = { bids: {}, offers: {} }; // Cache for display

  async function loadFileList() {
    try {
      const response = await fetch("/api/replay/files");
      const data = await response.json();

      if (data.success) {
        const select = document.getElementById("fileSelect");
        select.innerHTML = '<option value="">-- Select file --</option>';
        data.files.forEach((file) => {
          const option = document.createElement("option");
          option.value = file.path;
          option.textContent = `${file.date} - ${file.ticker}`;
          select.appendChild(option);
        });
      }
    } catch (error) {
      console.error("Error loading files:", error);
    }
  }

  async function loadFile() {
    const select = document.getElementById("fileSelect");
    const csvPath = select.value;

    if (!csvPath) {
      alert("Please select a file");
      return;
    }

    console.log("[LOAD] Loading file:", csvPath);
    document.getElementById("status").textContent = "Loading data...";

    try {
      // 1. Tell backend to load CSV (needed for parsing)
      const response = await fetch("/api/replay/load", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ csv_path: csvPath }),
      });

      const data = await response.json();
      
      if (!data.success) {
        throw new Error(data.error);
      }

      // 2. Fetch full dataset for client-side replay
      console.log("[LOAD] Fetching full dataset...");
      const dataResponse = await fetch("/api/replay/data");
      const fullData = await dataResponse.json();

      if (fullData.success) {
        replayData = fullData.rows; // [ts, price, lots, side]
        console.log(`[LOAD] Client-side data loaded: ${replayData.length} rows`);
        
        isClientSide = true;
        currentIndex = 0;
        replayState = "stopped";
        
        // Reset state
        orderbookState = { bids: {}, offers: {} };
        changeWindow = [];
        priceChangeCache = { bids: {}, offers: {} };
        
        // Update UI
        document.getElementById("status").textContent = "Ready (Client-Side)";
        document.getElementById("progress").textContent = `0/${replayData.length}`;
        document.getElementById("currentTime").textContent = "--:--:--";
        document.getElementById("updateCount").textContent = "0";
        
        // Setup scrubber
        const scrubber = document.getElementById("timeScrubber");
        scrubber.max = replayData.length - 1;
        scrubber.value = 0;
        scrubber.disabled = false;
        document.getElementById("scrubberPosition").textContent = `0 / ${replayData.length.toLocaleString()}`;
        
        // Initial render
        renderFrame(true); 

      } else {
        throw new Error("Failed to fetch full data");
      }

    } catch (error) {
      alert("Error: " + error.message);
      console.error("[LOAD] Exception:", error);
      document.getElementById("status").textContent = "Error";
    }
  }

  function startReplay() {
    const speed = parseFloat(document.getElementById("speedInput").value) || 10;
    playbackSpeed = speed;

    if (isClientSide) {
      console.log(`[START] Client-side replay @ ${speed}x`);
      replayState = "running";
      lastRenderTime = performance.now();
      
      // Update UI
      updateControlsRunning();
      
      // Start loop
      if (renderInterval) cancelAnimationFrame(renderInterval);
      renderInterval = requestAnimationFrame(gameLoop);
      
      return;
    }

    // Fallback to Server-Side
    startReplayServer(speed);
  }

  function pauseReplay() {
    if (isClientSide) {
      console.log("[PAUSE] Client-side paused");
      replayState = "paused";
      cancelAnimationFrame(renderInterval);
      updateControlsPaused();
      return;
    }
    pauseReplayServer();
  }

  function resumeReplay() {
    if (isClientSide) {
      console.log("[RESUME] Client-side resumed");
      replayState = "running";
      lastRenderTime = performance.now();
      renderInterval = requestAnimationFrame(gameLoop);
      updateControlsRunning();
      return;
    }
    resumeReplayServer();
  }

  function stopReplay() {
    if (isClientSide) {
      console.log("[STOP] Client-side stopped");
      replayState = "stopped";
      cancelAnimationFrame(renderInterval);
      
      currentIndex = 0;
      orderbookState = { bids: {}, offers: {} };
      changeWindow = [];
      priceChangeCache = { bids: {}, offers: {} };
      
      renderFrame(true); // Reset view
      updateControlsStopped();
      return;
    }
    stopReplayServer();
  }
  
  function updateControlsRunning() {
    document.getElementById("startBtn").disabled = true;
    document.getElementById("pauseBtn").disabled = false;
    document.getElementById("pauseBtn").style.display = "inline-block";
    document.getElementById("resumeBtn").disabled = true;
    document.getElementById("resumeBtn").style.display = "none";
    document.getElementById("stopBtn").disabled = false;
    document.getElementById("fileSelect").disabled = true;
    document.getElementById("timeScrubber").disabled = false;
    document.getElementById("status").textContent = "RUNNING (Client)";
    document.getElementById("speed").textContent = playbackSpeed + "x";
  }

  function updateControlsPaused() {
    document.getElementById("pauseBtn").disabled = true;
    document.getElementById("pauseBtn").style.display = "none";
    document.getElementById("resumeBtn").disabled = false;
    document.getElementById("resumeBtn").style.display = "inline-block";
    document.getElementById("stopBtn").disabled = false;
    document.getElementById("status").textContent = "PAUSED (Client)";
  }

  function updateControlsStopped() {
    document.getElementById("startBtn").disabled = false;
    document.getElementById("pauseBtn").disabled = true;
    document.getElementById("pauseBtn").style.display = "inline-block";
    document.getElementById("resumeBtn").disabled = true;
    document.getElementById("resumeBtn").style.display = "none";
    document.getElementById("stopBtn").disabled = true;
    document.getElementById("fileSelect").disabled = false;
    document.getElementById("status").textContent = "STOPPED (Client)";
    document.getElementById("speed").textContent = "1.0x";
    
    // Clear tables
    document.getElementById("bidBody").innerHTML = '<tr><td colspan="4" style="text-align:center; color:#888;">Stopped</td></tr>';
    document.getElementById("offerBody").innerHTML = '<tr><td colspan="4" style="text-align:center; color:#888;">Stopped</td></tr>';
  }

  function setSpeed() {
    const speed = parseFloat(document.getElementById("speedInput").value);
    playbackSpeed = speed;
    
    if (isClientSide) {
      document.getElementById("speed").textContent = speed + "x";
    } else {
      setSpeedServer(speed);
    }
  }
  
  function seekToPosition() {
    const scrubber = document.getElementById("timeScrubber");
    const position = parseInt(scrubber.value);
    
    if (isClientSide) {
      // Client-side seek (Instant!)
      
      // If dragging backwards, we need to rebuild state from 0
      // If dragging forwards, we can apply forward changes
      // For simplicity and correctness, we'll just rebuild from 0 if moving backwards
      // or if gap is too large.
      // But actually, for "scrubbing", we can just rebuild. 
      // JavaScript is fast enough to rebuild 100k rows in ms.
      
      // Optimization: Rebuild from scratch (safest)
      // On M1 Macbook, 1M iterations is < 10ms. 
      // If it's slow, we can optimize later.
      
      if (position < currentIndex) {
         // Moving back: full reset
         currentIndex = 0;
         orderbookState = { bids: {}, offers: {} };
      }
      
      // forward replay from currentIndex to position
      // We don't want to render every frame, just update state
      const targetIndex = Math.min(position, replayData.length - 1);
      
      while (currentIndex < targetIndex) {
         const row = replayData[currentIndex];
         // row: [ts, price, lots, side]
         // side 0=BID, 1=OFFER
         const side = row[3] === 0 ? 'bids' : 'offers';
         const price = row[1];
         const lots = row[2];
         
         orderbookState[side][price] = lots;
         currentIndex++;
      }
      
      // Reset change window on seek so we don't show old changes
      changeWindow = [];
      priceChangeCache = { bids: {}, offers: {} };
      
      // Fix: Sync virtualTime to the new position's timestamp
      if (currentIndex < replayData.length) {
          window.virtualTime = replayData[currentIndex][0];
      }
      
      // Update scrubber UI
      document.getElementById("scrubberPosition").textContent = `${currentIndex.toLocaleString()} / ${replayData.length.toLocaleString()}`;
      
      renderFrame(true);
      return;
    }
    
    seekToPositionServer(position);
  }

  // --- Client-Side Loop ---
  
  function gameLoop(timestamp) {
    if (replayState !== "running") return;
    
    // Calculate delta time
    const elapsed = timestamp - lastRenderTime;
    lastRenderTime = timestamp;
    
    // How many milliseconds of "market time" to advance?
    // elapsed (real ms) * playbackSpeed
    // e.g. 16ms * 10x = 160ms of market data
    
    // However, our data is tick-based, not strictly time-based in the array index.
    // But we have timestamps in row[0].
    
    if (currentIndex >= replayData.length) {
      stopReplay();
      return;
    }
    
    const currentRow = replayData[currentIndex];
    const currentTs = currentRow[0]; // timestamp in ms
    
    // We want to advance until: nextRow.timestamp > currentTs + (elapsed * speed)
    // But for simplicity in a tick-replay, we often just want to perform X ticks per frame?
    // Let's stick to time-based for accuracy.
    
    // We need a "virtual time" tracker
    if (!window.virtualTime) window.virtualTime = currentTs;
    window.virtualTime += (elapsed * playbackSpeed);
    
    // Process all rows that happened before virtualTime
    let updates = 0;
    while (currentIndex < replayData.length) {
      const row = replayData[currentIndex];
      if (row[0] > window.virtualTime) break; // Future event
      
      // Apply Update
      // row: [ts, price, lots, side]
      const price = row[1];
      const lots = row[2];
      const side = row[3] === 0 ? 'bids' : 'offers';
      
      // 10s Change Logic
      const oldLots = orderbookState[side][price] || 0;
      const change = lots - oldLots;
      
      if (change !== 0) {
        changeWindow.push({
           timestamp: row[0],
           price: price,
           side: side === 'bids' ? 'BID' : 'OFFER',
           change: change // Fix: Store signed change, not Math.abs
        });
      }
      
      // Update State
      orderbookState[side][price] = lots;
      
      currentIndex++;
      updates++;
      
      // Cap updates per frame to avoid freeze if speed is huge
      if (updates > 10000) {
        window.virtualTime = row[0]; // Sync time to avoid infinite catchup
        break;
      }
    }
    
    // Clean old changes (older than 10s from virtualTime)
    const cutoff = window.virtualTime - WINDOW_SIZE_MS;
    // Optimization: binary search or just filter (filter is O(N))
    // Since it's sorted by time, we can just slice from front
    while (changeWindow.length > 0 && changeWindow[0].timestamp < cutoff) {
      changeWindow.shift();
    }
    
    // Re-aggregate changes for display
    priceChangeCache = { bids: {}, offers: {} };
    for (const entry of changeWindow) {
        const s = entry.side === 'BID' ? 'bids' : 'offers';
        priceChangeCache[s][entry.price] = (priceChangeCache[s][entry.price] || 0) + entry.change;
    }

    // Render logic
    renderFrame();
    
    renderInterval = requestAnimationFrame(gameLoop);
  }
  
  function renderFrame(force = false) {
    // throttle rendering to 30fps? or just render every frame.
    // DOM updates are expensive.
    
    // Update basic stats
    document.getElementById("progress").textContent = `${currentIndex}/${replayData.length}`;
    if (replayData.length > 0 && currentIndex > 0) {
       const ts = new Date(replayData[currentIndex-1][0]); 
       document.getElementById("currentTime").textContent = ts.toLocaleTimeString("en-US", {hour12:false});
    }
    
    // Update Scrubber (visually only)
    document.getElementById("timeScrubber").value = currentIndex;
    
    // Sort and render top 20
    const bids = Object.entries(orderbookState.bids)
      .map(([p, l]) => ({price: parseFloat(p), lots: l}))
      .filter(x => x.lots > 0)
      .sort((a,b) => b.price - a.price)
      .slice(0, 20);
      
    const offers = Object.entries(orderbookState.offers)
      .map(([p, l]) => ({price: parseFloat(p), lots: l}))
      .filter(x => x.lots > 0)
      .sort((a,b) => a.price - b.price)
      .slice(0, 20);
      
     // Update HTML
     const bidBody = document.getElementById("bidBody");
     bidBody.innerHTML = bids.map(row => {
        const change10s = priceChangeCache.bids[row.price] || 0;
        return `<tr>
             <td>${row.price.toFixed(0)}</td>
             <td>${row.lots.toLocaleString()}</td>
             <td><span style="color:#888;">0</span></td> 
             <td style="font-size:0.9em;">${formatChange(change10s)}</td>
        </tr>`;
     }).join(""); // note: instantaneous change is hard to track in bulk, showing 0 for now or compute diff from last frame?
     // For simplicity, we just show 10s change. Instant change column is less useful in fast replay.
     
     const offerBody = document.getElementById("offerBody");
     offerBody.innerHTML = offers.map(row => {
        const change10s = priceChangeCache.offers[row.price] || 0;
        return `<tr>
             <td>${row.price.toFixed(0)}</td>
             <td>${row.lots.toLocaleString()}</td>
             <td><span style="color:#888;">0</span></td> 
             <td style="font-size:0.9em;">${formatChange(change10s)}</td>
        </tr>`;
     }).join("");
     
     document.getElementById("levels").textContent = bids.length + offers.length;
  }

  // --- Legacy Server Calls (Renamed) ---
  
  async function startReplayServer(speed) {
      console.log(`[START] Starting replay with speed ${speed}x`);
      const response = await fetch("/api/replay/start", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ speed_multiplier: speed }),
      });
      // ... (rest of old start logic if needed, but we rely on client side now)
      // For brevity, assuming client side works. logic is same as before.
      const data = await response.json();
      if (data.success) {
         replayState = "running";
         updateControlsRunning();
      }
  }
  
  async function pauseReplayServer() {
      const response = await fetch("/api/replay/pause", { method: "POST" });
       const data = await response.json();
       if(data.success) { replayState="paused"; updateControlsPaused(); }
  }
  
  async function resumeReplayServer() {
      const response = await fetch("/api/replay/resume", { method: "POST" });
      const data = await response.json();
       if(data.success) { replayState="running"; updateControlsRunning(); }
  }
  
  async function stopReplayServer() {
      await fetch("/api/replay/stop", { method: "POST" });
      replayState = "stopped";
      updateControlsStopped();
  }
  
  async function setSpeedServer(speed) {
      await fetch("/api/replay/speed", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ multiplier: speed }),
      });
  }
  
  async function seekToPositionServer(position) {
       await fetch("/api/replay/seek", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ position: position }),
      });
  }

  async function updateOrderbook() {
    // Only fetch API if running (not stopped or paused) AND not client-side
    if (replayState !== "running" || isClientSide) {
      return; 
    }

    try {
      const response = await fetch("/api/replay/orderbook");
      const data = await response.json();

      if (data.success) {
        // Update timestamp display
        if (data.current_timestamp) {
          const timestamp = new Date(data.current_timestamp);
          const timeStr = timestamp.toLocaleTimeString("en-US", {
            hour12: false,
          });
          document.getElementById("currentTime").textContent = timeStr;
        }

        const hasData = (data.bids && data.bids.length > 0) || (data.offers && data.offers.length > 0);

        if (hasData) {
          updateCount++;
          document.getElementById("updateCount").textContent = updateCount.toLocaleString();
        }

        // Update BID table
        const bidBody = document.getElementById("bidBody");
        if (data.bids && data.bids.length > 0) {
          bidBody.innerHTML = data.bids.map((row) => {
              return `<tr>
                <td>${row.price.toFixed(0)}</td>
                <td>${row.lots.toLocaleString()}</td>
                <td><span style="color:#888;">0</span></td>
                <td style="color:#888;">-</td>
              </tr>`;
            }).join("");
        }

        // Update OFFER table
        const offerBody = document.getElementById("offerBody");
        if (data.offers && data.offers.length > 0) {
          offerBody.innerHTML = data.offers.map((row) => {
              return `<tr>
                <td>${row.price.toFixed(0)}</td>
                <td>${row.lots.toLocaleString()}</td>
                <td><span style="color:#888;">0</span></td>
                <td style="color:#888;">-</td>
              </tr>`;
            }).join("");
        }
        
        if (data.running !== undefined) {
             document.getElementById("progress").textContent = `${data.index || 0}/${data.total_rows || 0}`;
        }
      }
    } catch (error) {
      console.error("Error updating orderbook:", error);
    }
  }

  function formatChange(change) {
    if (change === 0) return '<span style="color:#888;">0</span>';
    if (change > 0)
      return `<span class="change-positive">+${change.toLocaleString()}</span>`;
    return `<span class="change-negative">${change.toLocaleString()}</span>`;
  }

  function updateScrubberDisplay() {
    const scrubber = document.getElementById("timeScrubber");
    const max = parseInt(scrubber.max);
    const value = parseInt(scrubber.value);
    document.getElementById(
      "scrubberPosition",
    ).textContent = `${value.toLocaleString()} / ${max.toLocaleString()}`;
  }

  // Poll for updates continuously (but updateOrderbook checks replayState)
  pollInterval = setInterval(updateOrderbook, 100);

  // Initial load
  loadFileList();

  console.log("[INIT] Simple orderbook view initialized");
</script>
{% endblock %}
